package builderb0y.autocodec.util;

import java.io.IOException;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.util.Formattable;
import java.util.Formatter;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

public class TypeFormatter {

	public StringBuilder builder;
	public boolean annotations;
	public boolean simplify;

	public TypeFormatter(StringBuilder builder) {
		this.builder = builder;
		this.annotations = true;
		this.simplify = true;
	}

	public TypeFormatter(int initialCapacity) {
		this(new StringBuilder(initialCapacity));
	}

	public TypeFormatter annotations(boolean annotations) {
		this.annotations = annotations;
		return this;
	}

	public TypeFormatter simplify(boolean simplify) {
		this.simplify = simplify;
		return this;
	}

	public TypeFormatter append(String text) {
		this.builder.append(text);
		return this;
	}

	public TypeFormatter appendType(String type) {
		if (this.simplify) appendSimpleUnchecked(this.builder, type);
		else this.append(type);
		return this;
	}

	public TypeFormatter append(int value) {
		this.builder.append(value);
		return this;
	}

	public TypeFormatter append(long value) {
		this.builder.append(value);
		return this;
	}

	public TypeFormatter append(float value) {
		this.builder.append(value);
		return this;
	}

	public TypeFormatter append(double value) {
		this.builder.append(value);
		return this;
	}

	public TypeFormatter append(char value) {
		this.builder.append(value);
		return this;
	}

	public TypeFormatter append(boolean value) {
		this.builder.append(value);
		return this;
	}

	public TypeFormatter append(Class<?> clazz) {
		if (this.simplify) appendSimpleClassUnchecked(this.builder, clazz);
		else appendClassNameUnchecked(this.builder, clazz);
		return this;
	}

	public TypeFormatter append(Annotation annotation) {
		return this.appendType(annotation.toString());
	}

	public TypeFormatter append(TypeFormatterAppendable appendable) {
		appendable.appendTo(this);
		return this;
	}

	public TypeFormatter append(Object object) {
		if (object instanceof TypeFormatterAppendable appendable) return this.append(appendable);
		if (object instanceof Annotation annotation) return this.append(annotation);
		if (object instanceof Class<?> clazz) return this.append(clazz);
		return this.append(String.valueOf(object));
	}

	@Override
	public String toString() {
		return this.builder.toString();
	}

	/**
	appends the text to the appendable, but for every group of characters consisting
	of a {@link Character#isJavaIdentifierPart(char) java identifier} or a period ('.'),
	will only append the part of that group which is to the right of the *last* period.

	for text which represents a {@link Type},
	this will behave similarly to {@link Class#getSimpleName()}.
	however, this method treats $ as a valid group character,
	which will affect how inner classes are represented.
	for example, "dev.foo.codecs.FooCodec$Type1" would turn into "FooCodec$Type1".
	this differs from FooCodec.Type1.class.getSimpleName(), which would have returned "Type1" instead.

	this method takes a CharSequence as its argument instead of a Type so that
	it will still work with other sequences which resemble the format of Type.
	for example, you could call it with Field/Method/Constructor.toGenericString().

	returns the appendable, for convenience.
	*/
	@Contract("_, _ -> param1")
	public static <A extends Appendable> @NotNull A appendSimple(
		@NotNull A appendable,
		@NotNull CharSequence text
	)
	throws IOException {
		int length = text.length();
		int start = 0;
		for (int index = 0; index < length;) {
			char c = text.charAt(index++);
			if (!Character.isJavaIdentifierPart(c)) {
				if (c != '.') {
					appendable.append(text, start, index);
				}
				start = index;
			}
		}
		if (start < length) {
			appendable.append(text, start, length);
		}
		return appendable;
	}

	/**
	like the above method, but does not declare to throw any exceptions.
	this method will still throw an {@link IOException} if the appendable generates one,
	but this is not declared in the method signature.
	the primary use case for this method is when A is a {@link StringBuilder},
	since {@link StringBuilder#append} will never throw an IOException.

	a more subtle case is for use in {@link Formatter}.
	{@link Formatter} will call upon {@link Formattable} when provided,
	but {@link Formattable#formatTo(Formatter, int, int, int)}
	does not declare that it throws {@link IOException}.
	despite this, the relevant code inside {@link Formatter} will still
	catch {@link IOException}'s if they are generated by {@link Formattable}.
	so throwing unchecked {@link IOException}'s from
	{@link Formattable#formatTo(Formatter, int, int, int)} is safe.
	at least from jdk 8 to jdk 17 anyway. hopefully this does not become unsafe in later versions.
	ideally later versions will make {@link Formattable#formatTo(Formatter, int, int, int)}
	declare that it throws {@link IOException}, but at the time of writing this, that hasn't happened yet.
	*/
	@Contract("_, _ -> param1")
	public static <A extends Appendable> @NotNull A appendSimpleUnchecked(
		@NotNull A appendable,
		@NotNull CharSequence text
	) {
		try {
			return appendSimple(appendable, text);
		}
		catch (IOException exception) {
			throw AutoCodecUtil.rethrow(exception);
		}
	}

	/**
	appends the simple class name of the provided class to the provided appendable.
	the simple class name is the same as you would get from {@link #getSimpleClassName(Class)}.
	*/
	public static <A extends Appendable> @NotNull A appendSimpleClass(@NotNull A appendable, @NotNull Class<?> clazz) throws IOException {
		if (clazz.isAnonymousClass()) {
			Class<?>[] interfaces = clazz.getInterfaces();
			Class<?> substitute = interfaces.length == 1 ? interfaces[0] : clazz.getSuperclass();
			String subName = substitute.getName();
			appendable.append(subName, subName.lastIndexOf('.') + 1, subName.length()).append('@');
		}
		String name = clazz.getName();
		appendable.append(name, name.lastIndexOf('.') + 1, name.length());
		return appendable;
	}

	/**
	the unchecked version of {@link #appendSimpleClass(Appendable, Class)}.
	see {@link #appendSimpleUnchecked(Appendable, CharSequence)} for what unchecked means.
	*/
	public static <A extends Appendable> @NotNull A appendSimpleClassUnchecked(@NotNull A appendable, @NotNull Class<?> clazz) {
		try {
			return appendSimpleClass(appendable, clazz);
		}
		catch (IOException exception) {
			throw AutoCodecUtil.rethrow(exception);
		}
	}

	/**
	returns the "simple" name of the provided class.
	this method differs from {@link Class#getSimpleName()}
	in that this method includes the declaring class in the simple name.
	for example, class dev.foo.codecs.FooCodec$Type1 would return "FooCodec$Type1",
	not just "Type1", as would be returned by {@link Class#getSimpleName()}.

	if the class is anonymous, the simple name will include the declared type and the location.
	the declared type is what you used to instantiate the anonymous class.
	the location is the class in which the anonymous class is declared.
	for example, given the following code structure: {@code
		public class Example {

			public static final Runnable RUNNABLE = new Runnable() {
				...
			}
		}
	}
	the simple name of RUNNABLE.getClass() is "Runnable@Example$1".
	*/
	public static @NotNull String getSimpleClassName(@NotNull Class<?> clazz) {
		if (clazz.isAnonymousClass()) {
			Class<?>[] interfaces = clazz.getInterfaces();
			Class<?> substitute = interfaces.length == 1 ? interfaces[0] : clazz.getSuperclass();
			String subName = substitute.getName();
			String anonName = clazz.getName();
			return subName.substring(subName.lastIndexOf('.') + 1) + '@' + anonName.substring(anonName.lastIndexOf('.') + 1);
		}
		else {
			String name = clazz.getName();
			return name.substring(name.lastIndexOf('.') + 1);
		}
	}

	public static @NotNull String simplify(@NotNull CharSequence text) {
		return appendSimpleUnchecked(new StringBuilder(text.length()), text).toString();
	}

	/**
	returns the full name of the given class.
	similar to {@link #getSimpleClassName(Class)},
	but will not abbreviate leading packages.
	*/
	public static @NotNull String getClassName(@NotNull Class<?> clazz) {
		if (clazz.isAnonymousClass()) {
			Class<?>[] interfaces = clazz.getInterfaces();
			Class<?> substitute = interfaces.length == 1 ? interfaces[0] : clazz.getSuperclass();
			return substitute.getName() + '@' + clazz.getName();
		}
		else {
			return clazz.getName();
		}
	}

	public static <A extends Appendable> @NotNull A appendClassName(@NotNull A appendable, @NotNull Class<?> clazz) throws IOException {
		if (clazz.isAnonymousClass()) {
			Class<?>[] interfaces = clazz.getInterfaces();
			Class<?> substitute = interfaces.length == 1 ? interfaces[0] : clazz.getSuperclass();
			appendable.append(substitute.getName()).append('@');
		}
		appendable.append(clazz.getName());
		return appendable;
	}

	public static <A extends Appendable> @NotNull A appendClassNameUnchecked(@NotNull A appendable, @NotNull Class<?> clazz) {
		try {
			return appendClassName(appendable, clazz);
		}
		catch (IOException exception) {
			throw AutoCodecUtil.rethrow(exception);
		}
	}

	@FunctionalInterface
	public static interface TypeFormatterAppendable {

		public abstract void appendTo(TypeFormatter formatter);
	}
}